#summary Useful recipes for achieving certain tasks in Gridworks
#labels Featured

This page collects Gridworks recipes, small workflows and code fragments that show you how to achieve specific things with Gridworks.

== String Manipulation ==

Here are some examples of possible types of common string manipulation operations that you might encounter and how they can be achieved with the Gridworks Expression Language (GEL)

=== "someprefix_a2343" -> "a2343" ===

You can use 

{{{
  value.replace("someprefix_","")
}}}

basically replacing what you don't want with the empty string. 

Note that "replace" replaces all instances of that first string in the cell value so see the next recipe for that case.

=== "blah_2342_blah_1232" -> "2342_blah_1232"  ===

Here we can't replace "blah" with "" because it would change the second occurrence as well. So we can use this

{{{
   value.partition("blah_")[2]
}}}

that will chop the value in an array of three strings 

{{{
   ["", "blah_", "2342_blah_1232" ]
}}}

and we get the 3rd value (remember that the arrays in gridworks, like in most programming languages start from 0, so [2] is actually the third value).

=== "a:b:c:d:e" -> "b:c:d" ===

Sometimes the strings are more complicated and the only thing they have in common is a character separator. In that case it's handy to use "split" and "join" together like this:

{{{
   value.split(":")[1,3].join(":")
}}}

which "splits" the string around the ":" separating character in an array of 5 strings 

{{{
   ["a","b","c","d","e"]
}}}

then you select only the range between the 2nd and 4th and you get 

{{{
   ["b","c","d"]
}}}

then you join them together with the same separator character ":" and you get what you wanted "b:c:d".

=== "00003400340300004" -> ["000034","0034","03","00004"] ===

Sometimes your content has no char separator because the separation is performed by alignment (in the case of non-delimited files) and padded to certain sizes. In that case you can use

{{{
   value.splitByLengths(6,4,2,5)
}}}

where those numbers are the length of the fields respectively.

=== split / map / join ===

Running this expression

{{{
  forEach(value.split(" "), v, v + v.length()).join(";")
}}}

on the text

{{{
  abc defg hi
}}}

yields

{{{
  abc3;defg4;hi2
}}}

A similar trick can be used to compute, say, word length average

{{{
  with(value.split(" "), a, sum(forEach(a, v, v.length())) / a.length())
}}}

=== Merging several columns ===

You'd need to use the 'cells' variable:

{{{
  cells["col1"].value + ", " + cells["col2"].value
}}}

=== "AT&amp;amp;T" --> "AT&T" ===

Sometimes you get content that was extracted from web pages or XML documents and contain entities. These are very hard to deal with manually, mostly because there are tons of potential string values between "&" and ";". Gridworks provides you a convenient command to do this in GEL

{{{
  value.unescape("html")
}}}

Note the few entities are not part of HTML and are part of XML, so if you want to be safe, you can do

{{{
  value.unescape("html").unescape("xml")
}}}

which will take care of them both.

Note that sometimes a string can get escaped several times: "AT&amp;amp;amp;amp;amp;T" (yes, trust us, we've seen that in presumably good data sets). When you do a transform on such cells, make sure you check the "Re-transform until no change" checkbox. This causes the expression to get run on each cell's content until the output is the same as the input (or up to 10 times).

=== "AÃ¯n TÃ©muchent" ---> "Aïn Témuchent" ===

Sometimes content is aggregated from various sources and some where improperly decoded. This results in strings that contain 'garbled' content in the form of weird spurious characters. Fixing that is normally a very tedious and time consuming process, but Gridworks contains a handy GEL command specifically for that

{{{
  value.reinterpret("utf-8")
}}}

that does exactly that.

As a tip, if you see two weird characters where you think there should be one, try reinterpreting with "utf-8" which normally solves it. Other encoding values that are useful to try are "latin-1" (for european content), "Big5" (for chinese content"), etc. You can get a list of all the supported encodings [http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html here].  Re-encoding can also be done outside of Gridworks with text tools such as PSPad, Notepad++, etc.

== Numerical Conversions ==

=== Convert to Decimal Latitude or Longitude ===
For a string holding longitude/latitude information in the format XX degrees, XX minutes, XX.XX seconds the following can be used.

{{{
   forNonBlank(value[0,2], v, v.toNumber(), 0) +
   forNonBlank(value[2,4], v, v.toNumber()/60, 0) +
   forNonBlank(value[4,6], v, v.toNumber()/3600, 0) +
   forNonBlank(value[6,8], v, v.toNumber()/360000, 0)
}}}

== Error Handling ==

=== forNonBlank ===

Sometimes the cells in a column are not uniform, but your expression has to be flexible enough to handle them all. One case of nonuniformity is that the strings in the cells are not all of the same length, e.g., 3 cells in a column might contain

{{{
  200810
  20090312
  2010
}}}

This means that this formula

{{{
  value[0,4] + "-" + value[4,6] + "-" + value[6,8]
}}}

only works on the second cell. To catch the other cases, use the forNonBlank control:

{{{
  value[0,4] + forNonBlank(value[4,6], v, "-" + v, "") + forNonBlank(value[6,8], v, "-" + v, "")
}}}

This new expression transforms those cells to

{{{
  2008-10
  2009-03-12
  2010
}}}

What forNonBlank does is test its first argument and decides what to do based on whether that is blank (null or empty string) or not. If it's not blank, bind that value to the variable name in the second argument (v) and evaluates the third argument ("-" + v). Otherwise, it evaluates the forth argument ("").

== Spot Potential Encoding Issues ==

While Gridworks offers a convenient way to fix encoding issues with the "reinterpret" GEL command, it also helps you find where these problems could be since they can be hidden if most of the content has been properly decoded.

To do this, there is a special numeric facet called "Unicode charcode Facet" that generates a distribution of which unicode characters are used in a particular column. That distribution will allow you to spot outliers, meaning characters that are used infrequently and that might suggest encoding issues. You can use that char distribution facet to 'scan' and inspect the values for yourself and then use fix their encoding with the 'reinterpret' GEL function.

== Spot Values Potentially Placed in the wrong Column ==

Another useful numeric facet is the "Text Length Facet" which builds a distribution of lengths of the strings contained in a particular column. Here too spotting outliers, meaning strings that are too big or too small, might be an indication of a problem. 
